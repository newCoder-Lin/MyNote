基于zookeeper实现的分布式锁

加锁条件：
1.资源共享
2.共享资源
3.多任务环境

在单个JVM 环境下可以使用JDK提供的锁来加锁实现数据同步的作用。只能JVM内部线程的同步

当多个JVM环境下JDK提供的锁就不起作用，只用用外部锁来进行同步，各JVM去竞争获得锁。方法：

1.基于MySQL分布式锁。抢锁：往mysql中抢插一个锁。释放锁：删除刚才插入的值。
   可能存在的问题： a.死锁问题，即是无休止去等待锁。
		发生原因：获得锁的JVM宕机了，也就没机会释放锁。
		可是设置一个定时器进程，并且设置超时时间。当超过时间后获取结束JVM进程
		注意：为了解决单进程定时器问题，可以设置多个定时器进程。但会引来定时器间信息同步的问题。超时时间也很难判定，容易引来乱入锁的问题。还有超时时间过长带来系统效率的问题。

2.基于zookeeper实现分布式锁已经原理
1.zookeeper是分布式一致性服务框架
2.zk同一视图（客户端之间的数据展示是一致的）
3.存储数据  ， 类似于文件系统
	目录：持久、临时。（当创建持久目录的客户端断开连接时，该目录一只存在，而临时目录则不会存在。）


-----------------------------------------------------------------------------------------------------------------------
（分布式锁的前世今生）
视频内容主要包括： a.基于mysql的分布式锁	b.基于redis的分布式锁	c.基于zookeeper的分布式锁	d.各自优缺点	e.实现步骤及原理

Lock lock = new DistributedLock("ip:port,.....");	lock.lock();     lock.unlock();

使用锁的场景（条件）：
1.共享资源
2.共享资源是互斥的
3.多任务的环境

单机锁这能针对单个JVM进程去执行加锁操作。但对于分布式多节点多个JVM的操作，那么JDK和CAS加锁的操作已经无法满足需求了。因此只能使用外部的锁来保证。多个线程去对同一个资源进行抢锁操作，只有抢到锁才能往下执行代码。这就实现了线程前后排队的操作和保证了数据一致性、完整性。
1.基于mysql实现分布式锁
	所谓的锁是在mysql中加一个字段，多个JVM中的不同线程去mysql中去抢插一个字段。谁先插入了字段就意味着谁先抢到了锁。该线程执行完相关的操作后需要释放锁。
	即是每个JVM需要做三件事：getLock  select  insert filed 、 operator data 、 unlock
	
	引出的问题：
	但这种方式有很大的局限性，当设置线程睡眠的时候需要设置多要久时间才合适。如果不设置睡眠时间，那么JVM的线程每次都会轮询的去查看该字段的值是否存在，线程会做无用功，消耗大量的系统资源。
	同时还会有死锁的问题。当获得锁的JVM宕机了，那么它不会释放锁。其他JVM就会陷入无限等待中。
	
	解锁方式：
	可以用一个进程去监视mysql， 设置超时时间。当发现JVM超过设置的超时时间，那么进程就会把这把锁删了。这样可以在一定程度上解锁死锁。
	但为了防止该进程挂了，可以设置多个进程来监视mysql锁，但又会引出进程间数据同步的问题 。因为必须保证线程间通信延迟很低、数据一致。
	再者，超时时间的设置也是不好把控的一个东西。设置超时事假过短，JVM还未执行完逻辑锁就被释放了，会导致多个JVM同时操作同一共享资源，设置过长又会导致系统处理业务的能力降低。假设在某一过程JVM发生了fullGC，导致了处理时间超时了，也就是发生了乱入锁的问题。	

	可用性：通过该解决方案又会引出一系列的分布式问题，所以该方案并不是一个最优的解决方案。


2.基于redis实现分布式锁
	redis是一个基于内存的数据库，也可以将内存中数据持久化到数据库中，redis中的数据可以设置有效期。
	JVM想要获得分布式锁，可以往redis中去插入数据并设置有效期（expire），当锁的有效期时间到了，redis会去将这把说删除。但是这个锁的有限期也是很难拿捏的。本质跟mysql差不多
	注意：redis借助lua语言来实现它的分布式事务	

3.基于zookeeper的分布式锁
	zookeeper可以做为dubbo的注册中心，它是一个分布式一致性服务框架。
	特点：
	a.当你往zookeeper中插入一个数据的时候，该数据也会同步到其他的节点的zookeeper服务中。也就是数据一致性。给客户端一种统一视图的感觉，也就是数据一致性。
	b.zookeeper目录是可以存数据的，数据结构类似于文件系统。即是有目录有文件。目录下都是可以继续创建目录的。
	c.zookeeper的目录类型分为四种：持久化目录，临时目录，持久有顺序的目录，临时有序目录。
		持久化目录：当创建该目录的客户端与ZK的服务端断开连接的时候，该目录仍然存在。
		临时目录：当创建该目录的客户端与ZK的服务段凯凯连接的时候，该目录会被删除。
			-> zkServer.sh start
			-> zkCli.sh 
			-> rmr /filepath (删除目录下的文件)
			-> create   /filepah 999(创建一个持久目录节点，该节点的值是999)
			-> create -e /filepah/temp 888(创建一个临时目录节点，该节点的值是888)
			-> get  /filepah/temp
			888
			-> ls
		注意：当你创建临时节点的时候，客户端断开连接的时候并不是立刻直接删除临时目录文件。zk的服务端和客户端是通过一个心跳的机制来保持长连接的。客户端每隔一段时间会向服务端发送一个心跳包，代表客户端还存在。当超过一段时间没有收到心跳信息，zk服务端就会把临时目录给删除。也就是说临时文件最长需要经过一个心跳的时间才会被删除
		持久有顺序的目录：当创建该目录的客户端与ZK的服务端断开连接的时候，该目录仍然存在且带有序号。
			-> create -s /filepah/temp 666
			/filepah/temp0000000001
		临时有顺序的目录:
			-> create -e -s /filepah/temp 666
			/filepah/temp0000000002
	zk会为我们维护一个全局有序唯一的序号

4.zookeeper支持事件回调机制
	客户端可以往服务端文件目录节点上注册一个事件，当目录发生改变时就会回调客户端中的回调函数。
	实现思路：假设JVM1通过zk客户端可以往zkServer中去创建一个有顺序的临时节点。JVM2可以往这个临时节点中去注册一个删除事件。
		当JVM1执行完业务逻辑后断开客户端的连接，那么这个有序的临时节点就会被删除。同时会触发删除事件的回调机制，回调JVM2中回调函数中的逻辑。
		JVM2函数中又可以按照JVM1的方式根据所创建临时有序的节点，并在节点上注册下一个JVM回调函数触发的删除事件。以此类推。

	好处：
	1.节省资源，基于事件回调不需要轮询地去查看锁的情况，节省的资源。异步回调
	2.通过有序号临时节点和事件通知机制巧妙地解决了死锁问题。
	 







































































