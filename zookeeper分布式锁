基于zookeeper实现的分布式锁

加锁条件：
1.资源共享
2.共享资源
3.多任务环境

在单个JVM 环境下可以使用JDK提供的锁来加锁实现数据同步的作用。只能JVM内部线程的同步

当多个JVM环境下JDK提供的锁就不起作用，只用用外部锁来进行同步，各JVM去竞争获得锁。方法：

1.基于MySQL分布式锁。抢锁：往mysql中抢插一个锁。释放锁：删除刚才插入的值。
   可能存在的问题： a.死锁问题，即是无休止去等待锁。
		发生原因：获得锁的JVM宕机了，也就没机会释放锁。
		可是设置一个定时器进程，并且设置超时时间。当超过时间后获取结束JVM进程
		注意：为了解决单进程定时器问题，可以设置多个定时器进程。但会引来定时器间信息同步的问题。超时时间也很难判定，容易引来乱入锁的问题。还有超时时间过长带来系统效率的问题。

2.基于zookeeper实现分布式锁已经原理
1.zookeeper是分布式一致性服务框架
2.zk同一视图（客户端之间的数据展示是一致的）
3.存储数据  ， 类似于文件系统
	目录：持久、临时。持久有序目录，临时有序目录（当创建持久目录的客户端断开连接时，该目录依然存在，而临时目录则会随客户端的断开而一同消失。）
	zk客户端会每隔一段时间会向服务端来发送一次心跳来维持通信，也就是说临时目录的删除会在一个心跳的时间
	zk会维护一个全局并且有序唯一的序号
4.事件回调机制
	事件触发标准：例如目录丢失
	客户端可以向服务端目录中注册一个事件，而当事件发生后会触发客户端的回调函数实现相关的操作。
	
	JVM 会往Zk文件中去注册一个目录，JVM会去其他JVM中注册相应的事件以便于其他JVM的回调
	zk使用临时目录可以解决死锁问题，因为客户端和服务端需要进行心跳。

	基于zk实现的分布式可以节省资源，因为zk是基于事件通知的（异步回掉）。不像MYSQL其余未获得锁的线程需要往复的去轮询锁的信息，造成系统资源的浪费
	new DistrubtedLock();
	
